<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <title>Photos</title>
  <link rel="manifest" href="/manifest.json">
  <link href="vendor/vuetify/css/fonts.css" rel="stylesheet">
  <link href="vendor/vuetify/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="vendor/vuetify/vuetify-v2.2.19.min.css" rel="stylesheet">
  <link href="vendor/videojs/video-js.css" rel="stylesheet">
  <style>
    body, html {
      padding: 0;
      margin: 0;
    }
    body, html, #viewer {
      width: 100%;
      height: 100%;
    }

    #viewer {
      position: fixed;
      top: 0;
      left: 0;
    }
    
    .v-app {
      /* position: fixed;
      width: 100%; */
    }

    /* #app > .content { */
      /* position: fixed;
      top: 0;
      left: 0; */
      /* width: 100%; */
    /* } */

    .hide-scrollbar {
      overflow-y: scroll;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none;  /* Internet Explorer 10+ */
    }
    .hide-scrollbar::-webkit-scrollbar { /* WebKit */
      width: 0;
      height: 0;
    }

    .collections-nav {
      width: 100%;
    }

    .collections-nav a {
      text-decoration: none;
      color: unset;
    }

    .region {
      /* border: 10px solid rgba(65, 255, 81, 0.8); */
      color: white;
      pointer-events: all;
      width: 100%;
      height: 100%;
    }

    .config {
      position: absolute;
      width: 360px;
      left: calc(100vw - 380px);
      /* background: white; */
    }

    .toolbar {
      position: absolute;
      right: 40px;
      display: flex;
    }

    .toolbar > * {
      margin: 10px;
    }

    .config-toggle {
      position: absolute;
      top: 10px;
      right: 5px;
    }

    .controls {
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
      z-index: 10;
      background:rgba(255, 255, 255, 1);
      padding: 4px;
    }

    .controls .top-bar {
      display: flex;
      /* justify-content: end; */
      width: 100%;
      /* height: 60px; */
    }

    .navigation {
      position: absolute;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
    }

    .navigation .hitarea {
      position: absolute;
      width: 30%;
      height: 100%;
      /* background-color: red; */
      opacity: 0;
      /* pointer-events: all; */
    }

    .navigation .hitarea:hover {
      opacity: 1;
    }
    
    .navigation .hitarea.right {
      right: 0;
    }

    .navigation .hitarea .button {
      /* position: relative; */
      position: absolute;
      top: calc(50% - 64px/2);
    }

    /* .navigation .button {
      position: absolute;
      top: calc(50% - 64px/2);
      height: 100%;
    } */

    .navigation .hitarea.left .button {
      left: 10px;
    }

    .navigation .hitarea.right .button {
      left: calc(100% - 64px - 10px);
    }
    
    .video-icon {
      position: absolute;
      right: 5px;
      top: 5px;
    }

    .circle.button {
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 50%;
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .circle.button .icon {
      margin-top: 2px;
    }
    
    /* #image-ruler{
      background-color:red;
      width: 50px;
      height: 50px;
    } */

  </style>
</head>
<body>

  <div id="vue" style="visibility: hidden;">
    <page-title :title="pageTitle"></page-title>

    <v-app class="v-app">
      <v-app-bar
        fixed
        flat
        color="white"
        :value="nativeInteraction"
      >
        <v-app-bar-nav-icon @click="drawer = !drawer"></v-app-bar-nav-icon>
        <v-toolbar-title>Photos</v-toolbar-title>
        
        <v-spacer></v-spacer>
        
        <v-btn icon @click="refreshCache()">
          <v-icon>mdi-refresh</v-icon>
        </v-btn>

        <v-btn-toggle borderless class="mx-1" v-model="imageHeight">
          <v-btn value="30">
            <v-icon>mdi-image-size-select-small</v-icon>
          </v-btn>

          <v-btn :value="100">
            <v-icon>mdi-image-size-select-large</v-icon>
          </v-btn>

          <v-btn :value="300">
            <v-icon>mdi-image-size-select-actual</v-icon>
          </v-btn>
          
        </v-btn-toggle>
  
      </v-app-bar>
      
      <v-navigation-drawer
        v-model="drawer"
        fixed
        temporary
      >
        <v-list-item>
          <v-list-item-content>
            <v-list-item-icon>
            </v-list-item-icon>
            <v-list-item-title class="title">
              Photos
            </v-list-item-title>
            <v-list-item-subtitle>
              {{ scene.photoCount.toLocaleString() }} files
            </v-list-item-subtitle>
          </v-list-item-content>
        </v-list-item>
    
        <v-divider></v-divider>
    
        <v-list
          nav
        >
          <!-- <v-list-item
            link
          >
            <v-list-item-icon>
              <v-icon>mdi-view-dashboard</v-icon>
            </v-list-item-icon>

            <v-list-item-content>
              <v-list-item-title>Dashboard</v-list-item-title>
            </v-list-item-content>
          </v-list-item> -->

          <v-list-item>

            <v-list class="collections-nav">
              <v-list-item-group>
                <router-link
                v-for="collection in collections"
                :key="collection.id" :to="'/collections/' + collection.id">
                  <v-list-item
                  >
                    <v-list-item-content>
                        <v-list-item-title v-text="collection.name">
                        </v-list-item-title>
                    </v-list-item-content>
                  </v-list-item>
                </router-link>
              </v-list-item-group>
            </v-list>
            
            <!-- <v-select
              v-model="collectionSelectedId"
              :items="collections"
              item-text="name"
              item-value="id"
              solo
            >
            </v-select> -->

          </v-list-item>

          <v-list-item>
            <v-list-item-content>
              <v-slider
                v-model="imageHeight"
                min="1"
                max="400"
                label="Image Size"
              ></v-slider> 
            </v-list-item-content>
          </v-list-item>

          <v-list-item>
            <v-switch v-model="debug.overdraw" label="Debug Overdraw"></v-switch>
          </v-list-item>
          <v-list-item>
            <v-switch v-model="debug.thumbnails" label="Debug Thumbnails"></v-switch>
          </v-list-item>

  

        </v-list>

      </v-navigation-drawer>

      <div
        class="virtual-canvas"
        :style="{ height: canvasSize.height + 'px' }">
      </div>

      <div v-if="fullscreenControls" class="controls">
        
        <div class="top-bar">
          <h2>
            {{ collection.name }} #{{ focusRegion.data.id }}
          </h2>
          <v-btn
            icon
            v-if="focusRegion && focusRegion.data" 
            :href="`files/${focusRegion.data.id}/file/${focusRegion.data.filename}?${sceneParams}`"
            target="_blank"
            rel="noopener noreferrer"
          >
            <v-icon>mdi-open-in-new</v-icon>
          </v-btn>
        </div>
  
      </div>

      <div v-if="focusRegion" class="navigation">

        <div class="hitarea left" @click="navigate(-1)" @wheel="onNavigationWheel" @mousedown="onNavigationMouseDown">
          <div class="circle button">
            <v-icon class="icon" dark large>mdi-chevron-left</v-icon>
          </div>
        </div>
  
        <div class="hitarea right" @click="navigate(1)" @mousedown="onNavigationMouseDown">
          <div class="circle button">
            <v-icon class="icon" dark large>mdi-chevron-right</v-icon>
          </div>
        </div>
  
      </div>

      <div class="config">

        <v-card v-if="showConfig" class="px-4 pt-4 py-1">

          <v-slider
            class="mt-2"
            v-model="imageHeight"
            min="1"
            max="400"
            label="Image Size"
          ></v-slider> 

          <v-switch v-model="debug.overdraw" label="Debug Overdraw"></v-switch>
          <v-switch v-model="debug.thumbnails" label="Debug Thumbnails"></v-switch>
  
          <realtime-chart
            axis-label="Hit Ratio"
            :chart-data="getMetricsChartConfig()"
            :values="metricsHitRatio"
            postfix="%"
          ></realtime-chart>

          <realtime-chart
            axis-label="Cost"
            :chart-data="getMetricsChartConfig()"
            :values="metricsCost"
            scale="1000000"
            postfix=" MB"
          ></realtime-chart>
        </v-card>

      </div>
      
      <div class="region-pool" :key="regionPoolUpdateTime">
        <div
          v-for="region in regionPool"
          :key="region.poolId"
          :id="'region-' + region.poolId"
          class="region"
          @click="onRegionClick(region)">

          <div
            v-if="region.data && region.data.video"
            class="video-icon"
          >
            <v-icon color="#eee">
              mdi-play-circle-outline
            </v-icon>
          </div>

          <!-- {{ region.poolId }} {{ region.active }} -->

          <!-- v-if="region.data && region.data.video" -->
          <video-player
            v-if="region.data && region.data.video && focusRegion == region"
            :size="focusRegion == region ? 'full' : 'thumb'"
            :region="region"
            :params="sceneParams"
          ></video-player>

        </div>
      </div>

    </v-app>
    <div id="viewer"></div>
  </div>

  <!-- <div id="image-ruler"> </div> -->
  <script src="/vendor/openseadragon/openseadragon.js"></script>
  <script src="/vendor/openseadragon/openseadragon-smartScrollZoom.js"></script>
  <script src="/vendor/vue.js"></script>
  <script src="/vendor/vue-router.js"></script>
  <script src="/vendor/httpVueLoader.js"></script>
  <script src="/vendor/vuetify/vuetify-v2.2.19.js"></script>
  <script src="/vendor/moment.min.js"></script>
  <script src="/vendor/chartjs/Chart.js"></script>
  <script src="/vendor/chartjs/vue-chartjs.js"></script>
  <script src="/vendor/chartjs/chartjs-plugin-streaming.js"></script>
  <script src="/vendor/videojs/video.js"></script>
  <!-- <script src="/vendor/chartjs/chartjs-plugin-datalabels.js"></script> -->
  <script type="module">
  
  function debounce(callback, delay) {
      let timer = null;
      let pending = false;
      let pendingThis = null;
      let pendingArgs = null;
      function timeout() {
        timer = null;
        if (pending) {
          pending = false;
          timer = setTimeout(timeout, delay);
          callback.apply(pendingThis, pendingArgs);
        }
      }
      return function() {
        if (timer) {
          pending = true;
          pendingThis = this;
          pendingArgs = arguments;
          return;
        }
        callback.apply(this, arguments);
        timer = setTimeout(timeout, delay);
      };
    }

    function debounceWait(callback, delay) {
      let timer = null;
      let pending = false;
      let pendingThis = null;
      let pendingArgs = null;
      function timeout() {
        timer = null;
        if (pending) {
          pending = false;
          timer = setTimeout(timeout, delay);
          callback.apply(pendingThis, pendingArgs);
        }
      }
      return function() {
        if (timer) {
          pending = true;
          pendingThis = this;
          pendingArgs = arguments;
          clearTimeout(timer);
          timer = setTimeout(timeout, delay);
          return;
        }
        callback.apply(this, arguments);
        timer = setTimeout(timeout, delay);
      };
    }

    const overlays = [];
    const overlayById = {};
    const regionsById = {};
    
    Vue.use(httpVueLoader);

    const router = new VueRouter({
      routes: [
        { name: "collection", path: "/collections/:collection" },
        { name: "region", path: "/collections/:collection/:region" },
      ]
    })
    
    window.app = new Vue({
      el: '#vue',
      router,
      vuetify: new Vuetify(),
      components: {
        "video-player": "url:/components/VideoPlayer.vue",
        "page-title": "url:/components/PageTitle.vue",
      },
      data: {
        drawer: false,
        nativeInteraction: null,
        timestamp: 0,
        imageHeight: 100,
        collections: [],
        collectionSelectedId: null,
        cacheKey: null,
        scene: {
          bounds: {
            w: 0,
            h: 0,
          },
          photoCount: 0,
        },
        sceneParamsLoaded: null,
        view: {
          zoom: 0,
          width: 0,
          height: 0,
        },
        showConfig: false,
        metrics: null,
        // metricsInitialChartConfig: null,
        addedRegionsTime: 0,
        addedRegions: [],
        regionPool: [],
        regionPoolInUse: 0,
        regionPoolCount: 100,
        regionPoolUpdateTime: 0,
        regions: [],
        regionsUpdateTime: 0,
        regionsUpdateTimer: null,
        regionNavigationPendingId: 0,
        regionNavigationLoadedId: 0,
        focusRegion: null,
        focusRegionId: -1,
        focusRegionSetTime: null,
        focusRegionLoadIdOffset: 0,
        fullscreenControls: false,
        viewportBounds: {
          x: 0,
          y: 0,
          width: 1,
          height: 1,
          degrees: 0,
        },
        regionUpdatePending: false,
        regionUpdateRunning: false,
        debug: {
          overdraw: false,
          thumbnails: false,
        },
      },
      async created() {

        this.refreshCache();

        this.viewer = null;

        this.view.width = document.getElementById("viewer").clientWidth;

        window.addEventListener('wheel', this.onWheel);
        window.addEventListener('scroll', this.onScroll);
        window.addEventListener('touchstart', this.onTouchStart);
        window.addEventListener("click", this.onCanvasClick);
        await this.updateCollections();
        await this.updateScene();
        this.initSeadragon();
        await this.initRegionPool();
        await this.updateRegions();
        
        if (this.routeRegionId != null) {
          this.nativeInteraction = false;
          const region = await this.getOrFetchRegion(this.routeRegionId);
          // this.setFocusRegion(region);
          this.fitRegion(region, { immediate: true });
        } else {
          this.nativeInteraction = true;
        }

        if (!this.collection) {
          this.drawer = true;
        }

      },
      async mounted() {

        this.$el.style.visibility = "visible";
        
        this.tempRect = new OpenSeadragon.Rect();
        this.tempPoint = new OpenSeadragon.Point();
        this.scrollDebounce = false;
        this.scrollDebounceDirty = false;
        this.scrollDebounceTimer = null;
        this.lastScrollTime = 0;
        this.lastPanTime = 0;

        setInterval(() => this.timestamp = Date.now(), 1000)
        
      },
      destroyed() {
        window.removeEventListener('scroll', this.onScroll);
      },
      watch: {
        canvasSize() {
          this.onScrollNoDebounce();
        },
        view() {
          this.onScrollNoDebounce();
        },
        sceneParams: debounce(async function() {
          await this.updateScene();
          this.resetTiles();
        }, 500),
        viewportBounds(bounds) {
          // this.updateRegionsView();
          if (isNaN(bounds.x) || isNaN(bounds.y) || isNaN(bounds.width) || isNaN(bounds.height)) {
            console.warn("Invalid viewport bounds, ignoring update", bounds.x, bounds.y, bounds.width, bounds.height);
            return;
          }
          this.updateRegions();
        },
        debug: {
          handler() {
            this.resetTiles();
          },
          deep: true,
        },
        showConfig(showConfig) {
          clearInterval(this.metricsTimer);
          if (showConfig) {
            this.metricsTimer = setInterval(() => this.updateMetrics(), 1000);
          }
        },
        async routeRegionId(routeRegionId) {
          // console.log("routeRegionId", routeRegionId)
          if (Date.now() - this.focusRegionSetTime < 200) return;
          this.focusRegion = routeRegionId == null ? null : await this.getOrFetchRegion(routeRegionId);
          // console.log("focusRegion", this.focusRegion)
        },
        focusRegion(focusRegion, prevFocusRegion) {
          // console.log("watch", focusRegion && focusRegion.id);
          // if (!focusRegion && this.fullscreenControls) {
          //   this.fullscreenControls = false;
          // }
          // if (focusRegion) {
          //   // if (prevFocusRegion && prevFocusRegion.id == focusRegion.id) return;
          //   this.fitRegion(focusRegion, {
          //     animationTime: 0.1,
          //     immediate: true,
          //   });
          // }
          // setTimeout(() => {
          //   if (focusRegion) {
          //     document.documentElement.classList.add("hide-scrollbar");
          //   } else {
          //     document.documentElement.classList.remove("hide-scrollbar");
          //   }
          // }, 1000);
        },
        nativeInteraction(nativeInteraction) {
          if (nativeInteraction && this.fullscreenControls) {
            this.fullscreenControls = false;
          }

          const captureTouch = !nativeInteraction;
          this.viewer.setMouseNavEnabled(captureTouch);
          const touchAction = captureTouch ? 'none' : 'auto';
          
          const element = OpenSeadragon.getElement(this.viewer.canvas);
          if (typeof element.style.touchAction !== 'undefined') {
            element.style.touchAction = touchAction;
          } else if (typeof element.style.msTouchAction !== 'undefined') {
            element.style.msTouchAction = touchAction;
          }
        }
      },
      computed: {
        pageTitle() {
          if (!this.collection) {
            return "Photos";
          }
          if (!this.focusRegion) {
            return `${this.collection.name} - Photos`;
          }
          return `#${this.focusRegionId} - ${this.collection.name} - Photos`;
        },
        routeRegionId() {
          return this.$route.params.region;
        },
        collection() {
          const id = this.$route.params.collection;
          // console.log("collection", id)
          return this.collections.find(
            collection => collection.id == id
          );
          // if (!this.collectionSelectedId) {
          //   return { id: null };
          // }
          // return this.collections.find(
          //   collection => collection.id == this.collectionSelectedId
          // );
        },
        canvasSize() {
          const aspectRatio = this.scene.bounds.w / this.scene.bounds.h;
          return {
            width: this.view.width,
            height: this.view.width / aspectRatio,
          }
        },
        sceneParams() {
          const params = {
            collection: this.collection ? this.collection.id : null,
            imageHeight: this.imageHeight,
            sceneWidth: this.view.width,
            cacheKey: this.cacheKey,
          };
          return Object.entries(params).map(([key, value]) => `${key}=${value}`).join("&");
        },
        metricsHitRatio() {
          if (!this.metrics) return [];
          return Object.entries(this.metrics.imageSource.cache).map(([ key, value ], index) => {
            return {
              label: key,
              value: value.hit_ratio*100,
            }
          })
        },
        metricsCost() {
          if (!this.metrics) return [];
          return Object.entries(this.metrics.imageSource.cache).map(([ key, value ], index) => {
            return {
              label: key,
              value: value.cost.added - value.cost.evicted,
            }
          })
        },
      },
      methods: {

        refreshCache() {
          this.cacheKey = Date.now();
        },

        getMetricsChartConfig() {
          if (!this.metrics) return [];
          const chartColors = [
            'rgb(255, 99, 132)',
            'rgb(255, 159, 64)',
            'rgb(255, 205, 86)',
            'rgb(75, 192, 192)',
            'rgb(54, 162, 235)',
            'rgb(153, 102, 255)',
            'rgb(201, 203, 207)',
          ];
          const datasets = Object.entries(this.metrics.imageSource.cache)
          .map(([ key, value ], index) => {
            const color = chartColors[index % chartColors.length];
            return {
              label: key,
              fill: false,
              backgroundColor: color,
              borderColor: color,
            }
          })
          return {
            datasets,
          }
        },
        onScroll(event) {

          const now = Date.now();
          const elapsedSincePan = now - this.lastPanTime;
          if (elapsedSincePan < 50) return;
          // console.log("onScroll", event)

          if (this.scrollDebounce) {
            if (this.scrollDebounceTimer) {
              this.scrollDebounceDirty = true;
              return;
            }
            this.onScrollNoDebounce();
            this.scrollDebounceTimer = setTimeout(this.onScrollTimeout, 10);
          } else {
            this.onScrollNoDebounce();
          }

        },
        async onWheel(event) {
          if (event.ctrlKey && this.nativeInteraction) {
            event.preventDefault();
            if (event.deltaY < 0) {
              this.nativeInteraction = false;
              await Vue.nextTick();
              const newEvent = new event.constructor(event.type, event);
              event.target.dispatchEvent(newEvent);
            }
          }
        },
        async onTouchStart(event) {
          event.preventDefault();
          if (event.touches.length >= 2 && this.nativeInteraction) {
            this.nativeInteraction = false;
            await Vue.nextTick();
            const newEvent = new event.constructor(event.type, event);
            newEvent.preventDefault();
            event.target.dispatchEvent(newEvent);
          }
        },
        onScrollTimeout() {
          this.scrollDebounceTimer = null;
          if (this.scrollDebounceDirty) {
            this.scrollDebounceDirty = false;
            this.onScrollNoDebounce();
          }
        },
        onScrollNoDebounce() {
          if (!this.viewer) {
            this.scrollDebounceDirty = true;
            this.scrollDebounceTimer = setTimeout(this.onScrollTimeout, 100);
            return;
          }
          
          const viewport = this.viewer.viewport;
          const canvasAspectRatio = this.canvasSize.width / this.canvasSize.height;
          const viewerAspectRatio = this.view.width / this.view.height;
          const viewportViewWidth = 1;
          const viewportViewHeight = 1 / viewerAspectRatio;
          const viewportCanvasHeight = 1 / canvasAspectRatio;
          const viewportScrollHeight = viewportCanvasHeight - viewportViewHeight;

          const scrollMaxY = document.body.scrollHeight - window.innerHeight;
          const scrollRatio = scrollMaxY ? window.scrollY / scrollMaxY : 0;
          const viewportOffset = scrollRatio * viewportScrollHeight;
          
          // const point = this.tempPoint;
          // point.x = viewportViewWidth * 0.5;
          // point.y = viewportViewHeight * 0.5 + viewportOffset;
          const rect = this.tempRect;
          rect.x = 0;
          rect.y = viewportOffset;
          rect.width = viewportViewWidth;
          rect.height = viewportViewHeight;
          let immediate = !this.scrollDebounce;
          if (this.view.zoom > 1 && !this.scrollDebounce) {
            immediate = false;
            this.scrollDebounce = true;
            setTimeout(() => this.scrollDebounce = false, 1000);
          }
          // immediate = true;
          this.lastScrollTime = Date.now();
          // console.log("onScrollNoDebounce", rect, scrollMaxY)
          viewport.fitBounds(rect, immediate);
        },
        onViewerScroll(originalHandler, event) {
          // console.log("onViewerScroll")
          const originalEvent = event.originalEvent;
          originalEvent.preventDefault();
          originalHandler(event);
        },
        onViewerKeyDown(originalHandler, event) {
          switch (event.originalEvent.key) {
            case "ArrowLeft": this.navigate(-1); return;
            case "ArrowRight": this.navigate(1); return;
            case "Escape": this.navigateExit(); return;
          }
          // Propagate event
          return true;
        },
        onViewerPan(event) {
          // console.log("onViewerPan")
          // return;

          if (this.nativeInteraction) return;

          const now = Date.now();
          const elapsedSinceScroll = now - this.lastScrollTime;
          if (elapsedSinceScroll < 50) return;

          const viewport = this.viewer.viewport;
          const canvasAspectRatio = this.canvasSize.width / this.canvasSize.height;
          const viewerAspectRatio = this.view.width / this.view.height;
          const viewportViewWidth = 1;
          const viewportViewHeight = 1 / viewerAspectRatio;
          const viewportCanvasHeight = 1 / canvasAspectRatio;
          const viewportScrollHeight = viewportCanvasHeight - viewportViewHeight;
          
          const viewportOffset = event.center.y - viewportViewHeight * 0.5;

          const scrollRatio = viewportScrollHeight > 0 ? viewportOffset / viewportScrollHeight : 0;
          const scrollMaxY = document.body.scrollHeight - window.innerHeight;
          const scrollY = scrollRatio * scrollMaxY;
          this.lastPanTime = Date.now();
          // console.log(event)
          // Only for mouse...
          window.scrollTo(window.scrollX, scrollY);
        },
        resetTiles() {
          if (!this.viewer) return;
          var oldImage = this.viewer.world.getItemAt(0);
          // var oldBounds = oldImage.getBounds();
          // var oldSource = oldImage.source;
          // console.log(oldBounds, oldSource)
          const newSource = this.getTileSources();
          this.viewer.addTiledImage({
            tileSource: newSource,
            // x: oldBounds.x,
            // y: oldBounds.y,
            // width: oldBounds.width, // It'll do height automatically based on aspect ratio
            success: () => {
              if (oldImage) this.viewer.world.removeItem(oldImage);
            }
          });
        },
        async updateMetrics() {
          const metrics = await (await fetch("metrics")).json();
          if (!metrics) {
            throw new Error("Metrics not found");
          }
          const first = !this.metrics;
          this.metrics = metrics;
          // if (first) {
          //   this.metricsInitialChartConfig = this.metricsChartConfig;
          // }
        },
        async updateCollections() {
          const url = `collections`;
          const collections = await (await fetch(url)).json();
          this.collections = collections;
          this.collectionSelectedId = collections.length > 0 ? collections[0].id : null;
        },
        async updateScene() {
          if (this.collection == null) {
            return;
          }
          if (this.sceneParams == this.sceneParamsLoaded) {
            return;
          }
          this.sceneParamsLoaded = this.sceneParams;
          const url = `scenes?${this.sceneParams}`;
          const response = await fetch(url);
          if (!response.ok) {
            console.warn("Unable to update scene", response);
            return;
          }
          const scenes = await response.json();
          if (!scenes || scenes.length < 1) {
            throw new Error("Scene not found");
          }
          this.scene = scenes[0];
        },
        getTileSources() {
          const tileSize = 256
          const minLevel = 0
          const maxLevel = 20
          const power = 1 << maxLevel
          let width = power*tileSize
          let height = power*tileSize
          const sceneAspect = this.scene.bounds.w / this.scene.bounds.h;
          if (sceneAspect < 1) {
            width = height * sceneAspect;
          } else {
            height = width / sceneAspect;
          }
          if (width < 1) width = 1;
          if (height < 1) height = 1;
          return {
            width,
            height,
            tileSize,
            minLevel,
            maxLevel,
            getTileUrl: (level, x, y) => {
              let url = "tiles";
              url += "?" + this.sceneParams;
              url += "&tileSize=" + tileSize;
              url += "&zoom=" + level;
              url += "&x=" + x;
              url += "&y=" + y;
              for (const [key, value] of Object.entries(this.debug)) {
                url += "&debug" + key.slice(0, 1).toUpperCase() + key.slice(1) + "=" + (value ? "true" : "false");
              }
              return url;
            }
          }
        },
        initSeadragon() {

          this.viewer = OpenSeadragon({
            id: "viewer",
            prefixUrl: "/vendor/openseadragon/images/",
            tileSources: this.getTileSources(),
            // navigatorSizeRatio: 0.01,
            // panHorizontal: false,
            showNavigationControl: false,
            defaultZoomLevel: 1,
            // visibilityRatio: 	1,
            constrainDuringPan: true,
            // minZoomLevel: 1,
            viewportMargins: {
              left: 0,
              right: 0,
            },
            springStiffness: 10,
            // springStiffness: 3,
            gestureSettingsMouse: {
              // scrollToZoom: false,
              // flickEnabled: true,
              // flickMomentum: 0.25,
              // flickEnabled: false,
              clickToZoom: false,
              flickMomentum: 0.2,
              // dblClickToZoom: false
            },
            gestureSettingsTouch: {
              clickToZoom: false,
              flickMomentum: 0.2,
              flickEnabled: false,
            },
            animationTime: 0.1,
            zoomPerSecond: 1.0,
            zoomPerScroll: 1.5,
            // blendTime: 0.1,
            blendTime: 0.3,
            imageLoaderLimit: 10,
            // debugMode: true,
            // immediateRender: true,
            // zoomPerScroll: 2,
            // zoomPerSecond: 0.2,
            // mouseNavEnabled: false,
          });

          // console.log(this.viewer)

          // viewer.smartScrollZoom({
          //   enabled: true,
          //   minScrolls: 2,
          //   zoomIncrement: 0.2,
          //   timeThreshold: 500,
          // });



          this.viewer.addHandler("viewport-change", event => {
            // console.log("viewport-change")
            const viewport = event.eventSource.viewport;
            this.viewportBounds = viewport.getBounds();
          })

          this.viewer.addHandler("canvas-click", event => {
            // const viewport = event.eventSource.viewport;
            // event.preventDefaultAction = true;
            // console.log(event)
            if (!event.quick) return;
            this.onViewportClick(this.viewer.viewport.viewerElementToViewportCoordinates(event.position));
          })

          // viewer.addHandler("canvas-scroll", event => {
          //   // console.log(event);
          //   event.preventDefaultAction = true;
          //   event.preventDefault = true;
          // })

          this.viewer.addHandler("resize", event => {
            this.view.width = event.newContainerSize.x;
            this.view.height = event.newContainerSize.y;
          })
          const viewerElement = document.getElementById("viewer");
          this.view.width = viewerElement.clientWidth;
          this.view.height = viewerElement.clientHeight;

          this.viewer.addHandler("open", () => {
            // console.log("open")

            // Initializing pans a couple of times, so wait with this handler
            // until after initialization
            this.viewer.addHandler("pan", this.onViewerPan.bind(this));
          });

          this.viewer.addHandler("zoom", event => {
            const { zoom } = event;
            this.view.zoom = zoom;
            if (zoom < 0.9 && !this.nativeInteraction) {
              this.nativeInteraction = true;
              this.onScrollNoDebounce();
            }
          });

          this.viewer.innerTracker.keyDownHandler = this.onViewerKeyDown.bind(this, this.viewer.innerTracker.scrollHandler);
          this.viewer.innerTracker.scrollHandler = this.onViewerScroll.bind(this, this.viewer.innerTracker.scrollHandler);
          // viewer.innerTracker.nonPrimaryPressHandler = null;
          // viewer.innerTracker.nonPrimaryReleaseHandler = null;
          this.viewer.innerTracker.nonPrimaryPressHandler = event => {
            // Middle mouse propagation hack
            if (event.button == 1) {
              
              // This prevents later preventDefault() by momentarily disabling handlers
              const tracker = this.viewer.innerTracker;
              const clickHandler = tracker.clickHandler; tracker.clickHandler = null;
              const dblClickHandler = tracker.dblClickHandler; tracker.dblClickHandler = null;
              const pressHandler = tracker.pressHandler; tracker.pressHandler = null;
              const dragHandler = tracker.dragHandler; tracker.dragHandler = null;
              const dragEndHandler = tracker.dragEndHandler; tracker.dragEndHandler = null;
              const pinchHandler = tracker.pinchHandler; tracker.pinchHandler = null;
              setTimeout(() => {
                tracker.clickHandler = clickHandler;
                tracker.dblClickHandler = dblClickHandler;
                tracker.pressHandler = pressHandler;
                tracker.dragHandler = dragHandler;
                tracker.dragEndHandler = dragEndHandler;
                tracker.pinchHandler = pinchHandler;
              }, 0);
              
              // This prevents immediate preventDefault() in OpenSeadragon
              return true;
            }
          }

        },
        async initRegionPool() {
          this.regionPoolInUse = this.regionPoolCount;
          for (let i = 0; i < this.regionPoolCount; i++) {
            const region = {
              poolId: i,
              marked: false,
              id: 0,
              bounds: {
                x: 0,
                y: 0,
                w: 0,
                h: 0,
              },
              data: {},
              viewRatio: 0,
              distFromCenter: Infinity,
            }
            this.regionPool.push(region);
            this.releaseRegion(region);
          }

          await Vue.nextTick();

          for (let i = 0; i < this.regionPool.length; i++) {
            this.addOverlay(this.regionPool[i]);
          }
        },
        onRegionClick(region) {
          if (region == this.focusRegion) {
            this.fullscreenControls = !this.fullscreenControls;
          }
          if (this.nativeInteraction) {
            this.flyToRegion(region);
          }
        },

        onCanvasClick(event) {
          if (!this.nativeInteraction) return;
          if (event.target != this.viewer.drawer.canvas) {
            return;
          }
          this.tempPoint.x = event.clientX;
          this.tempPoint.y = event.clientY;
          this.onViewportClick(this.viewer.viewport.viewerElementToViewportCoordinates(this.tempPoint));
        },

        async flyToRegion(region) {
          if (this.nativeInteraction) {
            this.nativeInteraction = false;
            await Vue.nextTick();
          }

          this.setFocusRegion(region);

          const viewerBounds = this.viewer.viewport.getBounds();
          const viewerArea = viewerBounds.width * viewerBounds.height;
          const regionArea = region.bounds.w * region.bounds.h;
          const areaDiff = viewerArea/regionArea;
          // const animationTime = Math.abs(Math.log(areaDiff) / 2);
          const animationTime = Math.pow(areaDiff, 0.1);
          // console.log(areaDiff, animationTime);

          this.fitRegion(region, {
            animationTime,
          });
        },

        async onViewportClick(pos) {
          const regions = await this.getRegions(pos.x, pos.y, 0, 0);
          if (regions.length < 1) return;
          const region = regions[0];
          console.log(region.data.path);
          console.log(region);
          this.flyToRegion(region);
        },

        onNavigationMouseDown(event) {
          // Prevent focusing navigation elements
          event.preventDefault();
        },

        onNavigationWheel(event) {
          const viewerElement = document.getElementById("viewer");
          const redispatched = new MouseEvent(event.type, event);
          redispatched.explicitOriginalTarget = viewerElement;
          redispatched.target = viewerElement;
          redispatched.srcElement = viewerElement;
          viewerElement.dispatchEvent(redispatched);
          event.preventDefault();
        },

        fitRect(rect, options) {
          function withSpeed(animationTime, callback) {
            const viewport = this.viewer.viewport;
            const prevValues = {
              centerSpringX: viewport.centerSpringX.animationTime,
              centerSpringY: viewport.centerSpringY.animationTime,
              zoomSpring: viewport.zoomSpring.animationTime,
            }

            viewport.centerSpringX.animationTime =
            viewport.centerSpringY.animationTime =
            viewport.zoomSpring.animationTime =
            animationTime;

            callback();

            viewport.centerSpringX.animationTime = prevValues.centerSpringX;
            viewport.centerSpringY.animationTime = prevValues.centerSpringY;
            viewport.zoomSpring.animationTime = prevValues.zoomSpring;
          }

          let fitFunc = () => {
            this.viewer.viewport.fitBounds(rect, options.immediate)
          }

          if (options && options.animationTime) {
            fitFunc = withSpeed.bind(this, options.animationTime, fitFunc);
          }

          fitFunc();
        },

        fitRegion(region, options) {
          this.fitRect(new OpenSeadragon.Rect(
            region.bounds.x,
            region.bounds.y,
            region.bounds.w,
            region.bounds.h,
          ), options);
        },

        async navigate(offset) {
          const region = this.focusRegion;
          if (!region) return;
          if (this.focusRegionId == -1) {
            this.focusRegionId = region.id;
          }
          // this.focusRegionLoadIdOffset += offset;
          const beforeNavId = this.focusRegionId;
          const nextId = this.focusRegionId + offset;
          this.focusRegionId = nextId;
          // console.log(region.id, offset, this.focusRegionLoadIdOffset, nextId);
          // this.focusRegion = {
          //   id: nextId,
          // }
          const loadId = this.regionNavigationPendingId++;
          // console.log("loading", loadId, this.regionNavigationPendingId, this.regionNavigationLoadedId);
          const nextRegion = await this.getOrFetchRegion(nextId);
          // console.log("loaded", loadId, loadId >= this.regionNavigationLoadedId, this.regionNavigationPendingId, this.regionNavigationLoadedId);
          if (loadId < this.regionNavigationLoadedId) return;
          this.regionNavigationLoadedId = loadId;
          if (!nextRegion) {
            this.focusRegionId = beforeNavId;
            return;
          }
          // this.setFocusRegion(nextRegion);
          console.log(nextId, nextRegion.id);
          this.fitRegion(nextRegion, {
            animationTime: 0.1,
            immediate: true,
          });
        },
        async navigateExit() {
          const region = this.focusRegion;
          if (!region) return;
          // this.focusRegion = null;
          this.setFocusRegion(null);
          // this.nativeInteraction = true;
          // await Vue.nextTick();
          // this.fitRect(new OpenSeadragon.Rect(
          //   0, region.bounds.y,
          //   1, region.bounds.h,
          // ), {
          //   animationTime: 1
          // });
        },
        addOverlay(region) {
          // const overlay = {
          //   id: region.poolId,
          //   elementId: `region-${region.poolId}`,
          //   marked: false,
          // }
          // overlays.push(overlay);
          // overlayById[overlay.poolId] = overlay;
          // console.log(this.getOverlayId(region))
          this.viewer.addOverlay(
            this.getOverlayId(region),
            new OpenSeadragon.Rect(
              region.bounds.x,
              region.bounds.y,
              region.bounds.w,
              region.bounds.h
            ),
          );
        },
        getOverlayId(region) {
          return `region-${region.poolId}`
        },
        getRegion(id) {
          return regionsById[id];
        },
        async getOrFetchRegion(id) {
          let region = this.getRegion(id);
          if (!region) {
            region = await this.fetchRegion(id);
            this.addRegion(region);
          }
          return region;
        },
        addRegion(region) {
          if (!region) return;
          const poolRegion = this.acquireRegion();
          if (!poolRegion) return;
          Object.assign(poolRegion, {
            ...region,
            poolId: poolRegion.poolId,
            marked: false,
            active: false,
          });
          Vue.set(poolRegion, "data", region.data);
          this.regions.push(poolRegion);
          regionsById[region.id] = poolRegion;
          // console.log("add", region.id, region);
        },
        removeRegionAtIndex(index) {
          const removed = this.regions.splice(index, 1);
          if (removed.length != 1) {
            throw new Error("Unable to remove region");
          }
          const region = removed[0];
          // console.log("remove", region.id);
          delete regionsById[region.id];
          this.releaseRegion(region);
        },
        acquireRegion() {
          for (let i = 0; i < this.regionPool.length; i++) {
            const region = this.regionPool[i];
            if (region.id != -1) continue;
            this.regionPoolInUse++;
            // console.log("acquire", this.regionPoolInUse);
            return region;
          }
          return null;
          // throw new Error("Region pool exhausted: " + this.regionPool.length);
        },
        releaseRegion(region) {
          if (region.id == -1) {
            throw new Error("Tried to release already released region");
          }
          this.regionPoolInUse--;
          // console.log("release", this.regionPoolInUse);
          region.id = -1;
          region.active = false,
          region.bounds.x = -10000;
          region.bounds.y = -10000;
          region.bounds.w = 0;
          region.bounds.h = 0;
          region.data = null;
        },
        updateRegionOverlay(region) {
          // viewer.updateOverlay(
          //   this.getOverlayId(region),
          //   new OpenSeadragon.Rect(
          //     region.bounds.x,
          //     region.bounds.y,
          //     region.bounds.w,
          //     region.bounds.h
          //   ),
          // );
          const overlay = this.viewer.getOverlayById(this.getOverlayId(region));
          overlay.update(new OpenSeadragon.Rect(
            region.bounds.x,
            region.bounds.y,
            region.bounds.w,
            region.bounds.h
          ));
          this.updateRegionViewFromOverlay(region, overlay);
        },
        updateRegionsView() {
          for (let i = 0; i < this.regions.length; i++) {
            const region = this.regions[i];
            const overlay = this.viewer.getOverlayById(this.getOverlayId(region));
            this.updateRegionViewFromOverlay(region, overlay);
          }
        },
        updateRegionViewFromOverlay(region, overlay) {
          const overlayBounds = overlay.getBounds(this.viewer.viewport);
          const viewerBounds = this.viewer.viewport.getBounds();
          const widthRatio = overlayBounds.width / viewerBounds.width;
          const heightRatio = overlayBounds.height / viewerBounds.height;
          region.viewRatio = Math.max(widthRatio, heightRatio);
          const overlayCenterX = overlayBounds.x + overlayBounds.width/2;
          const overlayCenterY = overlayBounds.y + overlayBounds.height/2;
          const viewerCenterX = viewerBounds.x + viewerBounds.width/2;
          const viewerCenterY = viewerBounds.y + viewerBounds.height/2;
          region.distFromCenter = Math.sqrt(
            Math.pow(overlayCenterX - viewerCenterX, 2) +
            Math.pow(overlayCenterY - viewerCenterY, 2)
          );
          
          const inView =
            viewerCenterX > overlayBounds.x && 
            viewerCenterY > overlayBounds.y && 
            viewerCenterX < overlayBounds.x + overlayBounds.width && 
            viewerCenterY < overlayBounds.y + overlayBounds.height; 
          
          // if (region.viewRatio > 0.75 && region.viewRatio < 1.25 && region.distFromCenter < 0.03) {
          // console.log(region.viewRatio, inView)
          if (region.viewRatio > 0.5 && inView) {
            this.setFocusRegion(region);
          } else {
            // if (this.focusRegion == region) this.setFocusRegion(null);
          }
        },
        setFocusRegion(region) {
          console.log("set", region && region.id);
          this.focusRegionSetTime = Date.now();
          if (region === null) {
            this.focusRegionId = -1;
            this.focusRegion = region;
            this.focusRegionLoadIdOffset = 0;
            if (!this.$route.params.region) return;
            this.pushRegionDelayed(this.collection, null);
          } else {
            this.focusRegionId = region.id;
            if (this.focusRegion && this.focusRegion.id == region.id) return;
            this.focusRegion = region;
            this.focusRegionLoadIdOffset = 0;
            this.pushRegionDelayed(this.collection, region);
          }
        },
        pushRegionDelayed: debounceWait(async function(collection, region) {
          console.log("push", region && region.id);
          if (region && this.routeRegionId == region.id) return;
          this.$router.push({
            name: region ? "region" : "collection",
            params: {
              collection: collection.id,
              region: region?.id,
            },
          })
        }, 1000),
        async updateRegionPool() {

          // const addedRegions = [];
          // for (let i = 0; i < overlays.length; i++) {
          //   const overlay = overlays[i];
          //   overlay.marked = true;
          // }
          // for (let i = 0; i < regions.length; i++) {
          //   const region = regions[i];
          //   const overlay = overlayById[region.id];
          //   if (overlay) {
          //     overlay.marked = false;
          //   } else {
          //     addedRegions.push(region);
          //   }
          // }
          // for (let i = overlays.length - 1; i >= 0; i--) {
          //   const overlay = overlays[i];
          //   if (overlay.marked) {
          //     viewer.removeOverlay(overlay.elementId);
          //     overlays.splice(i, 1);
          //     delete overlayById[overlay.id];
          //     // console.log("remove", overlay.id);
          //   }
          // }

          // this.addedRegions = addedRegions;
          // this.addedRegionsTime = Date.now();
          // await Vue.nextTick();

          // for (let i = 0; i < addedRegions.length; i++) {
          //   const region = addedRegions[i];
          //   const overlay = {
          //     id: region.id,
          //     elementId: `region-${region.id}`,
          //     marked: false,
          //   }
          //   overlays.push(overlay);
          //   overlayById[overlay.id] = overlay;
          //   viewer.addOverlay(
          //     overlay.elementId,
          //     new OpenSeadragon.Rect(
          //       region.bounds.x,
          //       region.bounds.y,
          //       region.bounds.w,
          //       region.bounds.h
          //     ),
          //   );
          //   console.log("add", overlay.id);
          // }
        },
        async getRegions(x, y, w, h) {
          const url = `regions?${this.sceneParams}&x=${x}&y=${y}&w=${w}&h=${h}`;
          const response = await fetch(url);
          if (!response.ok) return [];
          return await response.json();
        },
        async fetchRegion(id) {
          const url = `regions/${id}?${this.sceneParams}`;
          const response = await fetch(url);
          if (!response.ok) return null;
          return await response.json();
        },
        async updateRegions() {
          if (this.regionUpdateRunning) {
            this.regionUpdatePending = true;
            return;
          }
          this.regionUpdateRunning = true;
          const regions = (await this.getRegions(
            this.viewportBounds.x,
            this.viewportBounds.y,
            this.viewportBounds.width,
            this.viewportBounds.height,
          ))
          // .filter(region => region.data && region.data.video)

          for (let i = 0; i < this.regions.length; i++) {
            const region = this.regions[i];
            region.marked = true;
          }

          for (let i = 0; i < regions.length; i++) {
            const region = regions[i];
            const existingRegion = this.getRegion(region.id);
            if (existingRegion) {
              existingRegion.marked = false;
            } else {
              this.addRegion(region);
            }
          }

          for (let i = this.regions.length - 1; i >= 0; i--) {
            const region = this.regions[i];
            if (region.marked) {
              this.removeRegionAtIndex(i);
              this.updateRegionOverlay(region);
            }
          }

          for (let i = 0; i < this.regions.length; i++) {
            const region = this.regions[i];
            // console.log("update", region.id, this.getOverlayId(region), region.bounds.x, region.bounds.y, region.bounds.w, region.bounds.h)
            this.updateRegionOverlay(region);
            // const area = region.bounds.w * region.bounds.h;
            // console.log(area);
          }
          
          if (this.regionUpdatePending) {
            setTimeout(() => {
              this.regionUpdatePending = false;
              this.regionUpdateRunning = false;
              this.updateRegions();
            }, 250);
          } else {
            this.regionUpdateRunning = false;
          }


          // const addedRegions = [];
          // for (let i = 0; i < overlays.length; i++) {
          //   const overlay = overlays[i];
          //   overlay.marked = true;
          // }
          // for (let i = 0; i < regions.length; i++) {
          //   const region = regions[i];
          //   const overlay = overlayById[region.id];
          //   if (overlay) {
          //     overlay.marked = false;
          //   } else {
          //     addedRegions.push(region);
          //   }
          // }
          // for (let i = overlays.length - 1; i >= 0; i--) {
          //   const overlay = overlays[i];
          //   if (overlay.marked) {
          //     viewer.removeOverlay(overlay.elementId);
          //     overlays.splice(i, 1);
          //     delete overlayById[overlay.id];
          //     // console.log("remove", overlay.id);
          //   }
          // }

          // this.addedRegions = addedRegions;
          // this.addedRegionsTime = Date.now();
          // await Vue.nextTick();

          // for (let i = 0; i < addedRegions.length; i++) {
          //   const region = addedRegions[i];
          //   const overlay = {
          //     id: region.id,
          //     elementId: `region-${region.id}`,
          //     marked: false,
          //   }
          //   overlays.push(overlay);
          //   overlayById[overlay.id] = overlay;
          //   viewer.addOverlay(
          //     overlay.elementId,
          //     new OpenSeadragon.Rect(
          //       region.bounds.x,
          //       region.bounds.y,
          //       region.bounds.w,
          //       region.bounds.h
          //     ),
          //   );
          //   console.log("add", overlay.id);
          // }

          // if (this.regionUpdatePending) {
          //   await new Promise(resolve => setTimeout(resolve, 1000));
          //   this.regionUpdatePending = false;
          //   this.regionUpdateRunning = false;
          //   this.updateRegions();
          // } else {
          //   this.regionUpdateRunning = false;
          // }

          // this.regionsUpdateTime = Date.now();
          // viewer.clearOverlays();
          // await Vue.nextTick();
          // this.regions.forEach(region => {
          //   viewer.addOverlay(
          //     `region-${region.id}`,
          //     new OpenSeadragon.Rect(
          //       region.bounds.x,
          //       region.bounds.y,
          //       region.bounds.w,
          //       region.bounds.h
          //     ),
          //   );
          // });
          // if (this.regionUpdatePending) {
          //   await new Promise(resolve => setTimeout(resolve, 500));
          //   this.regionUpdatePending = false;
          //   this.regionUpdateRunning = false;
          //   this.updateRegions();
          // } else {
          //   this.regionUpdateRunning = false;
          // }
        }
      },
    })
  </script>
</body>
</html>