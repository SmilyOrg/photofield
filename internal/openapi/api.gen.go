// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for LayoutType.
const (
	ALBUM    LayoutType = "ALBUM"
	SQUARE   LayoutType = "SQUARE"
	STRIP    LayoutType = "STRIP"
	TIMELINE LayoutType = "TIMELINE"
	WALL     LayoutType = "WALL"
)

// Defines values for Operation.
const (
	ADD      Operation = "ADD"
	INVERT   Operation = "INVERT"
	SUBTRACT Operation = "SUBTRACT"
)

// Defines values for TaskType.
const (
	INDEXCONTENTS      TaskType = "INDEX_CONTENTS"
	INDEXCONTENTSAI    TaskType = "INDEX_CONTENTS_AI"
	INDEXCONTENTSCOLOR TaskType = "INDEX_CONTENTS_COLOR"
	INDEXFILES         TaskType = "INDEX_FILES"
	INDEXMETADATA      TaskType = "INDEX_METADATA"
)

// Bounds defines model for Bounds.
type Bounds struct {
	H float32 `json:"h"`
	W float32 `json:"w"`
	X float32 `json:"x"`
	Y float32 `json:"y"`
}

// Capabilities defines model for Capabilities.
type Capabilities struct {
	Docs   DocsCapability `json:"docs"`
	Search Capability     `json:"search"`
	Tags   Capability     `json:"tags"`
}

// Capability defines model for Capability.
type Capability struct {
	Supported bool `json:"supported"`
}

// Collection defines model for Collection.
type Collection struct {
	Id CollectionId `json:"id"`

	// IndexedAt Time of latest performed full index
	IndexedAt *time.Time `json:"indexed_at,omitempty"`

	// Name User-friendly name
	Name *string `json:"name,omitempty"`
}

// CollectionId defines model for CollectionId.
type CollectionId = string

// DocsCapability defines model for DocsCapability.
type DocsCapability struct {
	Supported bool `json:"supported"`

	// Url URL to the documentation to link to from the UI.
	Url string `json:"url"`
}

// FileBinary defines model for FileBinary.
type FileBinary = openapi_types.File

// FileId defines model for FileId.
type FileId = int

// ImageHeight defines model for ImageHeight.
type ImageHeight = float32

// LayoutType defines model for LayoutType.
type LayoutType string

// Limit defines model for Limit.
type Limit = int

// Operation defines model for Operation.
type Operation string

// Problem defines model for Problem.
type Problem struct {
	// Status The HTTP status code generated by the origin server for this occurrence of the problem.
	Status *int32 `json:"status,omitempty"`

	// Title A short summary of the problem type. Written in English and readable for engineers, usually not suited for non technical stakeholders and not localized.
	Title *string `json:"title,omitempty"`
}

// Region defines model for Region.
type Region struct {
	Bounds Bounds      `json:"bounds"`
	Data   *RegionData `json:"data,omitempty"`
	Id     RegionId    `json:"id"`
}

// RegionData defines model for RegionData.
type RegionData = map[string]interface{}

// RegionId defines model for RegionId.
type RegionId = int

// Scene defines model for Scene.
type Scene struct {
	Bounds *Bounds `json:"bounds,omitempty"`

	// Error Any error encountered while loading the scene
	Error     *string `json:"error,omitempty"`
	FileCount *int    `json:"file_count,omitempty"`
	Id        SceneId `json:"id"`
	LoadCount *int    `json:"load_count,omitempty"`
	LoadUnit  *string `json:"load_unit,omitempty"`

	// Loading True while the scene is loading and the dimensions are not yet known.
	Loading *bool `json:"loading,omitempty"`
}

// SceneId defines model for SceneId.
type SceneId = string

// SceneParams defines model for SceneParams.
type SceneParams struct {
	CollectionId   CollectionId   `json:"collection_id"`
	ImageHeight    *ImageHeight   `json:"image_height,omitempty"`
	Layout         LayoutType     `json:"layout"`
	Search         *Search        `json:"search,omitempty"`
	Sort           *Sort          `json:"sort,omitempty"`
	Tweaks         *Tweaks        `json:"tweaks,omitempty"`
	ViewportHeight ViewportHeight `json:"viewport_height"`
	ViewportWidth  ViewportWidth  `json:"viewport_width"`
}

// Search defines model for Search.
type Search = string

// Sort defines model for Sort.
type Sort = string

// Tag defines model for Tag.
type Tag struct {
	// Etag ETag for optimistic concurrency control
	Etag      *string    `json:"etag,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// TagFilesPost Perform the specified tag operation for the specified files.
// You need to provide either a `scene_id` & `bounds` or `file_id`.
type TagFilesPost struct {
	Bounds  *Bounds   `json:"bounds,omitempty"`
	FileId  *FileId   `json:"file_id,omitempty"`
	Op      Operation `json:"op"`
	SceneId *SceneId  `json:"scene_id,omitempty"`
	TagId   *TagId    `json:"tag_id,omitempty"`
}

// TagId defines model for TagId.
type TagId = string

// Tags defines model for Tags.
type Tags = []Tag

// TagsPost Create a new tag based on the provided parameters.
type TagsPost struct {
	CollectionId *CollectionId `json:"collection_id,omitempty"`
	Selection    *bool         `json:"selection,omitempty"`
}

// Task defines model for Task.
type Task struct {
	CollectionId *CollectionId `json:"collection_id,omitempty"`

	// Done Number of items already processed.
	Done *int   `json:"done,omitempty"`
	Id   TaskId `json:"id"`
	Name string `json:"name"`

	// Pending Number of items pending as part of the task.
	Pending *int      `json:"pending,omitempty"`
	Type    *TaskType `json:"type,omitempty"`
}

// TaskId defines model for TaskId.
type TaskId = string

// TaskType defines model for TaskType.
type TaskType string

// TileCoord defines model for TileCoord.
type TileCoord = int

// Tweaks defines model for Tweaks.
type Tweaks = string

// ViewportHeight defines model for ViewportHeight.
type ViewportHeight = float32

// ViewportWidth defines model for ViewportWidth.
type ViewportWidth = float32

// FileIdPathParam defines model for FileIdPathParam.
type FileIdPathParam = FileId

// FilenamePathParam defines model for FilenamePathParam.
type FilenamePathParam = string

// SearchParam defines model for SearchParam.
type SearchParam = Search

// SizePathParam defines model for SizePathParam.
type SizePathParam = string

// TagIdPathParam defines model for TagIdPathParam.
type TagIdPathParam = TagId

// GetScenesParams defines parameters for GetScenes.
type GetScenesParams struct {
	// CollectionId Collection ID
	CollectionId   CollectionId    `form:"collection_id" json:"collection_id"`
	ViewportWidth  *ViewportWidth  `form:"viewport_width,omitempty" json:"viewport_width,omitempty"`
	ViewportHeight *ViewportHeight `form:"viewport_height,omitempty" json:"viewport_height,omitempty"`
	ImageHeight    *ImageHeight    `form:"image_height,omitempty" json:"image_height,omitempty"`
	Layout         *LayoutType     `form:"layout,omitempty" json:"layout,omitempty"`
	Sort           *Sort           `form:"sort,omitempty" json:"sort,omitempty"`
	Search         *Search         `form:"search,omitempty" json:"search,omitempty"`
	Tweaks         *Tweaks         `form:"tweaks,omitempty" json:"tweaks,omitempty"`
	Limit          *Limit          `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetScenesSceneIdDatesParams defines parameters for GetScenesSceneIdDates.
type GetScenesSceneIdDatesParams struct {
	Height int `form:"height" json:"height"`
}

// GetScenesSceneIdRegionsParams defines parameters for GetScenesSceneIdRegions.
type GetScenesSceneIdRegionsParams struct {
	FileId *FileId  `form:"file_id,omitempty" json:"file_id,omitempty"`
	X      *float32 `form:"x,omitempty" json:"x,omitempty"`
	Y      *float32 `form:"y,omitempty" json:"y,omitempty"`
	W      *float32 `form:"w,omitempty" json:"w,omitempty"`
	H      *float32 `form:"h,omitempty" json:"h,omitempty"`
	Limit  *Limit   `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetScenesSceneIdTilesParams defines parameters for GetScenesSceneIdTiles.
type GetScenesSceneIdTilesParams struct {
	TileSize         int       `form:"tile_size" json:"tile_size"`
	BackgroundColor  *string   `form:"background_color,omitempty" json:"background_color,omitempty"`
	TransparencyMask *bool     `form:"transparency_mask,omitempty" json:"transparency_mask,omitempty"`
	Zoom             int       `form:"zoom" json:"zoom"`
	X                TileCoord `form:"x" json:"x"`
	Y                TileCoord `form:"y" json:"y"`
	Sources          *[]string `form:"sources,omitempty" json:"sources,omitempty"`

	// SelectTag Show images with this tag as selected.
	SelectTag       *string `form:"select_tag,omitempty" json:"select_tag,omitempty"`
	DebugOverdraw   *bool   `form:"debug_overdraw,omitempty" json:"debug_overdraw,omitempty"`
	DebugThumbnails *bool   `form:"debug_thumbnails,omitempty" json:"debug_thumbnails,omitempty"`
	QualityPreset   *string `form:"quality_preset,omitempty" json:"quality_preset,omitempty"`
}

// GetTagsParams defines parameters for GetTags.
type GetTagsParams struct {
	// Q Search custom text query
	Q *SearchParam `form:"q,omitempty" json:"q,omitempty"`
}

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Type Task type to filter on.
	Type *TaskType `form:"type,omitempty" json:"type,omitempty"`

	// CollectionId Collection ID for the tasks
	CollectionId *CollectionId `form:"collection_id,omitempty" json:"collection_id,omitempty"`
}

// PostTasksJSONBody defines parameters for PostTasks.
type PostTasksJSONBody struct {
	CollectionId CollectionId `json:"collection_id"`
	Type         TaskType     `json:"type"`
}

// PostScenesJSONRequestBody defines body for PostScenes for application/json ContentType.
type PostScenesJSONRequestBody = SceneParams

// PostTagsJSONRequestBody defines body for PostTags for application/json ContentType.
type PostTagsJSONRequestBody = TagsPost

// PostTagsIdFilesJSONRequestBody defines body for PostTagsIdFiles for application/json ContentType.
type PostTagsIdFilesJSONRequestBody = TagFilesPost

// PostTasksJSONRequestBody defines body for PostTasks for application/json ContentType.
type PostTasksJSONRequestBody PostTasksJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /capabilities)
	GetCapabilities(w http.ResponseWriter, r *http.Request)

	// (GET /collections)
	GetCollections(w http.ResponseWriter, r *http.Request)

	// (GET /collections/{id})
	GetCollectionsId(w http.ResponseWriter, r *http.Request, id CollectionId)

	// (GET /files/{id})
	GetFilesId(w http.ResponseWriter, r *http.Request, id FileIdPathParam)

	// (GET /files/{id}/original/{filename})
	GetFilesIdOriginalFilename(w http.ResponseWriter, r *http.Request, id FileIdPathParam, filename FilenamePathParam)

	// (GET /files/{id}/variants/{size}/{filename})
	GetFilesIdVariantsSizeFilename(w http.ResponseWriter, r *http.Request, id FileIdPathParam, size SizePathParam, filename FilenamePathParam)

	// (GET /scenes)
	GetScenes(w http.ResponseWriter, r *http.Request, params GetScenesParams)

	// (POST /scenes)
	PostScenes(w http.ResponseWriter, r *http.Request)

	// (GET /scenes/{id})
	GetScenesId(w http.ResponseWriter, r *http.Request, id SceneId)

	// (GET /scenes/{scene_id}/dates)
	GetScenesSceneIdDates(w http.ResponseWriter, r *http.Request, sceneId SceneId, params GetScenesSceneIdDatesParams)

	// (GET /scenes/{scene_id}/regions)
	GetScenesSceneIdRegions(w http.ResponseWriter, r *http.Request, sceneId SceneId, params GetScenesSceneIdRegionsParams)

	// (GET /scenes/{scene_id}/regions/{id})
	GetScenesSceneIdRegionsId(w http.ResponseWriter, r *http.Request, sceneId SceneId, id RegionId)

	// (GET /scenes/{scene_id}/tiles)
	GetScenesSceneIdTiles(w http.ResponseWriter, r *http.Request, sceneId SceneId, params GetScenesSceneIdTilesParams)

	// (GET /tags)
	GetTags(w http.ResponseWriter, r *http.Request, params GetTagsParams)

	// (POST /tags)
	PostTags(w http.ResponseWriter, r *http.Request)

	// (GET /tags/{id})
	GetTagsId(w http.ResponseWriter, r *http.Request, id TagIdPathParam)

	// (POST /tags/{id}/files)
	PostTagsIdFiles(w http.ResponseWriter, r *http.Request, id TagIdPathParam)

	// (GET /tags/{id}/files-tags)
	GetTagsIdFilesTags(w http.ResponseWriter, r *http.Request, id TagIdPathParam)

	// (GET /tasks)
	GetTasks(w http.ResponseWriter, r *http.Request, params GetTasksParams)

	// (POST /tasks)
	PostTasks(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// (GET /capabilities)
func (_ Unimplemented) GetCapabilities(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /collections)
func (_ Unimplemented) GetCollections(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /collections/{id})
func (_ Unimplemented) GetCollectionsId(w http.ResponseWriter, r *http.Request, id CollectionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /files/{id})
func (_ Unimplemented) GetFilesId(w http.ResponseWriter, r *http.Request, id FileIdPathParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /files/{id}/original/{filename})
func (_ Unimplemented) GetFilesIdOriginalFilename(w http.ResponseWriter, r *http.Request, id FileIdPathParam, filename FilenamePathParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /files/{id}/variants/{size}/{filename})
func (_ Unimplemented) GetFilesIdVariantsSizeFilename(w http.ResponseWriter, r *http.Request, id FileIdPathParam, size SizePathParam, filename FilenamePathParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /scenes)
func (_ Unimplemented) GetScenes(w http.ResponseWriter, r *http.Request, params GetScenesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /scenes)
func (_ Unimplemented) PostScenes(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /scenes/{id})
func (_ Unimplemented) GetScenesId(w http.ResponseWriter, r *http.Request, id SceneId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /scenes/{scene_id}/dates)
func (_ Unimplemented) GetScenesSceneIdDates(w http.ResponseWriter, r *http.Request, sceneId SceneId, params GetScenesSceneIdDatesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /scenes/{scene_id}/regions)
func (_ Unimplemented) GetScenesSceneIdRegions(w http.ResponseWriter, r *http.Request, sceneId SceneId, params GetScenesSceneIdRegionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /scenes/{scene_id}/regions/{id})
func (_ Unimplemented) GetScenesSceneIdRegionsId(w http.ResponseWriter, r *http.Request, sceneId SceneId, id RegionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /scenes/{scene_id}/tiles)
func (_ Unimplemented) GetScenesSceneIdTiles(w http.ResponseWriter, r *http.Request, sceneId SceneId, params GetScenesSceneIdTilesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /tags)
func (_ Unimplemented) GetTags(w http.ResponseWriter, r *http.Request, params GetTagsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /tags)
func (_ Unimplemented) PostTags(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /tags/{id})
func (_ Unimplemented) GetTagsId(w http.ResponseWriter, r *http.Request, id TagIdPathParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /tags/{id}/files)
func (_ Unimplemented) PostTagsIdFiles(w http.ResponseWriter, r *http.Request, id TagIdPathParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /tags/{id}/files-tags)
func (_ Unimplemented) GetTagsIdFilesTags(w http.ResponseWriter, r *http.Request, id TagIdPathParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /tasks)
func (_ Unimplemented) GetTasks(w http.ResponseWriter, r *http.Request, params GetTasksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /tasks)
func (_ Unimplemented) PostTasks(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetCapabilities(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCapabilities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCollections operation middleware
func (siw *ServerInterfaceWrapper) GetCollections(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCollections(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCollectionsId operation middleware
func (siw *ServerInterfaceWrapper) GetCollectionsId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id CollectionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCollectionsId(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFilesId operation middleware
func (siw *ServerInterfaceWrapper) GetFilesId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id FileIdPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFilesId(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFilesIdOriginalFilename operation middleware
func (siw *ServerInterfaceWrapper) GetFilesIdOriginalFilename(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id FileIdPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename FilenamePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "filename", chi.URLParam(r, "filename"), &filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFilesIdOriginalFilename(w, r, id, filename)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFilesIdVariantsSizeFilename operation middleware
func (siw *ServerInterfaceWrapper) GetFilesIdVariantsSizeFilename(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id FileIdPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "size" -------------
	var size SizePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "size", chi.URLParam(r, "size"), &size, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename FilenamePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "filename", chi.URLParam(r, "filename"), &filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFilesIdVariantsSizeFilename(w, r, id, size, filename)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScenes operation middleware
func (siw *ServerInterfaceWrapper) GetScenes(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScenesParams

	// ------------- Required query parameter "collection_id" -------------

	if paramValue := r.URL.Query().Get("collection_id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "collection_id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "collection_id", r.URL.Query(), &params.CollectionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection_id", Err: err})
		return
	}

	// ------------- Optional query parameter "viewport_width" -------------

	err = runtime.BindQueryParameter("form", true, false, "viewport_width", r.URL.Query(), &params.ViewportWidth)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "viewport_width", Err: err})
		return
	}

	// ------------- Optional query parameter "viewport_height" -------------

	err = runtime.BindQueryParameter("form", true, false, "viewport_height", r.URL.Query(), &params.ViewportHeight)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "viewport_height", Err: err})
		return
	}

	// ------------- Optional query parameter "image_height" -------------

	err = runtime.BindQueryParameter("form", true, false, "image_height", r.URL.Query(), &params.ImageHeight)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "image_height", Err: err})
		return
	}

	// ------------- Optional query parameter "layout" -------------

	err = runtime.BindQueryParameter("form", true, false, "layout", r.URL.Query(), &params.Layout)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "layout", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "tweaks" -------------

	err = runtime.BindQueryParameter("form", true, false, "tweaks", r.URL.Query(), &params.Tweaks)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tweaks", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScenes(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostScenes operation middleware
func (siw *ServerInterfaceWrapper) PostScenes(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostScenes(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScenesId operation middleware
func (siw *ServerInterfaceWrapper) GetScenesId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id SceneId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScenesId(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScenesSceneIdDates operation middleware
func (siw *ServerInterfaceWrapper) GetScenesSceneIdDates(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "scene_id" -------------
	var sceneId SceneId

	err = runtime.BindStyledParameterWithOptions("simple", "scene_id", chi.URLParam(r, "scene_id"), &sceneId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scene_id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScenesSceneIdDatesParams

	// ------------- Required query parameter "height" -------------

	if paramValue := r.URL.Query().Get("height"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "height"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "height", r.URL.Query(), &params.Height)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "height", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScenesSceneIdDates(w, r, sceneId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScenesSceneIdRegions operation middleware
func (siw *ServerInterfaceWrapper) GetScenesSceneIdRegions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "scene_id" -------------
	var sceneId SceneId

	err = runtime.BindStyledParameterWithOptions("simple", "scene_id", chi.URLParam(r, "scene_id"), &sceneId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scene_id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScenesSceneIdRegionsParams

	// ------------- Optional query parameter "file_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "file_id", r.URL.Query(), &params.FileId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	// ------------- Optional query parameter "x" -------------

	err = runtime.BindQueryParameter("form", true, false, "x", r.URL.Query(), &params.X)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x", Err: err})
		return
	}

	// ------------- Optional query parameter "y" -------------

	err = runtime.BindQueryParameter("form", true, false, "y", r.URL.Query(), &params.Y)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "y", Err: err})
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", r.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "w", Err: err})
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", r.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "h", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScenesSceneIdRegions(w, r, sceneId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScenesSceneIdRegionsId operation middleware
func (siw *ServerInterfaceWrapper) GetScenesSceneIdRegionsId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "scene_id" -------------
	var sceneId SceneId

	err = runtime.BindStyledParameterWithOptions("simple", "scene_id", chi.URLParam(r, "scene_id"), &sceneId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scene_id", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id RegionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScenesSceneIdRegionsId(w, r, sceneId, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScenesSceneIdTiles operation middleware
func (siw *ServerInterfaceWrapper) GetScenesSceneIdTiles(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "scene_id" -------------
	var sceneId SceneId

	err = runtime.BindStyledParameterWithOptions("simple", "scene_id", chi.URLParam(r, "scene_id"), &sceneId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scene_id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScenesSceneIdTilesParams

	// ------------- Required query parameter "tile_size" -------------

	if paramValue := r.URL.Query().Get("tile_size"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "tile_size"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "tile_size", r.URL.Query(), &params.TileSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tile_size", Err: err})
		return
	}

	// ------------- Optional query parameter "background_color" -------------

	err = runtime.BindQueryParameter("form", true, false, "background_color", r.URL.Query(), &params.BackgroundColor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "background_color", Err: err})
		return
	}

	// ------------- Optional query parameter "transparency_mask" -------------

	err = runtime.BindQueryParameter("form", true, false, "transparency_mask", r.URL.Query(), &params.TransparencyMask)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "transparency_mask", Err: err})
		return
	}

	// ------------- Required query parameter "zoom" -------------

	if paramValue := r.URL.Query().Get("zoom"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "zoom"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "zoom", r.URL.Query(), &params.Zoom)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "zoom", Err: err})
		return
	}

	// ------------- Required query parameter "x" -------------

	if paramValue := r.URL.Query().Get("x"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "x"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "x", r.URL.Query(), &params.X)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x", Err: err})
		return
	}

	// ------------- Required query parameter "y" -------------

	if paramValue := r.URL.Query().Get("y"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "y"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "y", r.URL.Query(), &params.Y)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "y", Err: err})
		return
	}

	// ------------- Optional query parameter "sources" -------------

	err = runtime.BindQueryParameter("form", false, false, "sources", r.URL.Query(), &params.Sources)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sources", Err: err})
		return
	}

	// ------------- Optional query parameter "select_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "select_tag", r.URL.Query(), &params.SelectTag)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "select_tag", Err: err})
		return
	}

	// ------------- Optional query parameter "debug_overdraw" -------------

	err = runtime.BindQueryParameter("form", true, false, "debug_overdraw", r.URL.Query(), &params.DebugOverdraw)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "debug_overdraw", Err: err})
		return
	}

	// ------------- Optional query parameter "debug_thumbnails" -------------

	err = runtime.BindQueryParameter("form", true, false, "debug_thumbnails", r.URL.Query(), &params.DebugThumbnails)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "debug_thumbnails", Err: err})
		return
	}

	// ------------- Optional query parameter "quality_preset" -------------

	err = runtime.BindQueryParameter("form", true, false, "quality_preset", r.URL.Query(), &params.QualityPreset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quality_preset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScenesSceneIdTiles(w, r, sceneId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTags operation middleware
func (siw *ServerInterfaceWrapper) GetTags(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTagsParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTags(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostTags operation middleware
func (siw *ServerInterfaceWrapper) PostTags(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostTags(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTagsId operation middleware
func (siw *ServerInterfaceWrapper) GetTagsId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TagIdPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTagsId(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostTagsIdFiles operation middleware
func (siw *ServerInterfaceWrapper) PostTagsIdFiles(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TagIdPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostTagsIdFiles(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTagsIdFilesTags operation middleware
func (siw *ServerInterfaceWrapper) GetTagsIdFilesTags(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TagIdPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTagsIdFilesTags(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTasks operation middleware
func (siw *ServerInterfaceWrapper) GetTasks(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "collection_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "collection_id", r.URL.Query(), &params.CollectionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTasks(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostTasks operation middleware
func (siw *ServerInterfaceWrapper) PostTasks(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostTasks(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/capabilities", wrapper.GetCapabilities)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections", wrapper.GetCollections)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{id}", wrapper.GetCollectionsId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}", wrapper.GetFilesId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}/original/{filename}", wrapper.GetFilesIdOriginalFilename)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}/variants/{size}/{filename}", wrapper.GetFilesIdVariantsSizeFilename)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scenes", wrapper.GetScenes)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/scenes", wrapper.PostScenes)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scenes/{id}", wrapper.GetScenesId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scenes/{scene_id}/dates", wrapper.GetScenesSceneIdDates)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scenes/{scene_id}/regions", wrapper.GetScenesSceneIdRegions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scenes/{scene_id}/regions/{id}", wrapper.GetScenesSceneIdRegionsId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/scenes/{scene_id}/tiles", wrapper.GetScenesSceneIdTiles)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tags", wrapper.PostTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags/{id}", wrapper.GetTagsId)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tags/{id}/files", wrapper.PostTagsIdFiles)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags/{id}/files-tags", wrapper.GetTagsIdFilesTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tasks", wrapper.GetTasks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/tasks", wrapper.PostTasks)
	})

	return r
}
